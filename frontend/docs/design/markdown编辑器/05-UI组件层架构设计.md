# UI 组件层架构设计文档

## 一、整体架构

### 1.1 组件层级关系

```
MarkdownEditor.vue (容器组件/智能组件)
    ├─ EditorToolbar.vue (UI组件/展示组件)
    └─ EditorContent.vue (核心组件/智能组件)
```

### 1.2 设计模式

采用 **容器/展示（Container/Presentational）** 模式：

| 组件             | 类型     | 职责                                         |
| ---------------- | -------- | -------------------------------------------- |
| `MarkdownEditor` | 容器组件 | 组合子组件、协调数据流、对外暴露统一 API     |
| `EditorToolbar`  | 展示组件 | 纯 UI，发出事件，无状态                      |
| `EditorContent`  | 智能组件 | 管理编辑状态、实现编辑逻辑、拥有 Composables |

---

## 二、EditorContent.vue 详细设计

### 2.1 组件定位

**核心编辑组件**，负责所有编辑相关的底层逻辑。

### 2.2 职责清单

| 职责类别     | 具体内容                                                 |
| ------------ | -------------------------------------------------------- |
| **状态管理** | 管理 `editorState`（内容、选区、历史等）                 |
| **DOM 管理** | 管理 `contenteditable` 元素的引用                        |
| **逻辑集成** | 初始化并管理 `useSelection`、`useMarkdown`、`useHistory` |
| **数据同步** | 实现 v-model 双向绑定                                    |
| **API 暴露** | 通过 `defineExpose` 暴露方法给父组件                     |
| **事件处理** | 处理 `input`、`keydown` 等底层事件                       |

### 2.3 数据流设计

#### 输入（Props）

```typescript
interface Props {
  modelValue?: string // 编辑器内容（v-model）
}
```

#### 输出（Emits）

```typescript
interface Emits {
  (e: 'update:modelValue', value: string): void // 内容变化
}
```

#### 内部状态

```typescript
// 核心引用
const editorRef = ref<HTMLDivElement | null>(null)

// 完整编辑器状态
const editorState = reactive<EditorState>({
  // Content Layer
  title: '',
  content: '',

  // History Layer
  transactions: [],
  currentIndex: -1,

  // UI Layer
  selection: { start: 0, end: 0, selectedText: '', isEmpty: true },
  isSaving: false,
  isDirty: false,
  isFocused: false,

  // Error Layer
  hasError: false,

  // Computed Cache
  canUndo: false,
  canRedo: false,
})
```

### 2.4 Composables 初始化策略

```typescript
// 初始化顺序很重要！
const selectionAPI = useSelection(editorRef, editorState) // 1. 基础选区管理
const markdownAPI = useMarkdown(editorState, selectionAPI) // 2. 依赖选区的格式化
const historyAPI = useHistory(editorState) // 3. 独立的历史管理
```

**为什么在子组件初始化？**

- ✅ 数据就近原则：`editorRef` 和 `editorState` 都在这里
- ✅ 封装原则：父组件不需要知道内部实现
- ✅ 职责单一：EditorContent 负责编辑逻辑

### 2.5 暴露的 API

```typescript
defineExpose({
  // Selection API
  getSelectionInfo: () => SelectionInfo,
  setCursor: (position: number) => void,
  selectRange: (start: number, end: number) => void,
  replaceRange: (start: number, end: number, text: string) => void,
  insertText: (text: string) => void,
  wrapText: (before: string, after: string) => void,
  getCurrentLineInfo: () => LineInfo,

  // Markdown API
  applyInlineFormat: (action: InlineFormatType) => void,
  applyParagraphFormat: (action: ParagraphFormatType) => void,
  insertBlock: (action: BlockInsertType) => void,

  // History API
  undo: () => string | null,
  redo: () => string | null,
  canUndo: ComputedRef<boolean>,
  canRedo: ComputedRef<boolean>,
  pushTransaction: (content: string, label: string) => void,

  // Direct Access
  editorElement: Ref<HTMLDivElement | null>,
  state: EditorState,
})
```

### 2.6 关键实现细节

#### v-model 双向绑定

```typescript
// Props → 内部状态
watch(
  () => props.modelValue,
  (newValue) => {
    if (newValue !== undefined && editorRef.value && newValue !== editorState.content) {
      editorRef.value.innerHTML = newValue
      editorState.content = newValue
    }
  },
  { immediate: true },
)

// 内部状态 → Props（通过 emit）
watch(
  () => editorState.content,
  (newContent) => {
    if (newContent && newContent !== props.modelValue) {
      emit('update:modelValue', newContent)
    }
  },
)
```

#### 快捷键处理

```typescript
const handleKeyDown = (event: KeyboardEvent) => {
  const isMod = event.ctrlKey || event.metaKey // 跨平台支持

  // 撤销：Ctrl+Z / Cmd+Z
  if (isMod && event.key === 'z' && !event.shiftKey) {
    event.preventDefault()
    const previousContent = historyAPI.undo()
    if (previousContent !== null && editorRef.value) {
      // 三处同步更新
      editorRef.value.innerHTML = previousContent
      editorState.content = previousContent
      emit('update:modelValue', previousContent)
    }
  }

  // 重做：Ctrl+Shift+Z / Cmd+Shift+Z
  if (isMod && event.key === 'z' && event.shiftKey) {
    event.preventDefault()
    const nextContent = historyAPI.redo()
    if (nextContent !== null && editorRef.value) {
      editorRef.value.innerHTML = nextContent
      editorState.content = nextContent
      emit('update:modelValue', nextContent)
    }
  }
}
```

---

## 三、EditorToolbar.vue 详细设计

### 3.1 组件定位

**纯 UI 组件**，只负责展示工具栏和发出事件，不包含任何业务逻辑。

### 3.2 职责清单

| 职责类别     | 具体内容                             |
| ------------ | ------------------------------------ |
| **UI 展示**  | 渲染工具栏按钮（图标 + 提示）        |
| **事件分发** | 将用户点击转换为分类事件             |
| **类型判断** | 智能识别操作类型（行内、段落、块级） |

### 3.3 设计原则

#### 无状态（Stateless）

```typescript
// ✅ 无内部状态
// ❌ 不存储选中的格式
// ❌ 不存储编辑器内容
// ❌ 不直接操作 DOM
```

#### 事件驱动（Event-Driven）

```typescript
// 只发出事件，不执行逻辑
emit('inline-format', 'bold')
emit('paragraph-format', 'heading1')
emit('insert-block', 'codeBlock')
```

### 3.4 事件分发设计

#### 为什么要分类事件？

**问题**：如果所有按钮都发出同一个事件，父组件需要自己判断类型：

```typescript
// ❌ 不好的设计
emit('format', 'bold')
emit('format', 'heading1')
emit('format', 'codeBlock')

// 父组件需要自己判断
const handleFormat = (action: string) => {
  if (['bold', 'italic', ...].includes(action)) {
    // 行内格式
  } else if (['heading1', 'heading2', ...].includes(action)) {
    // 段落格式
  } else {
    // 块级插入
  }
}
```

**解决方案**：工具栏自己判断类型，发出分类事件：

```typescript
// ✅ 好的设计
interface Emits {
  (e: 'inline-format', action: InlineFormatType): void
  (e: 'paragraph-format', action: ParagraphFormatType): void
  (e: 'insert-block', action: BlockInsertType): void
}

// 智能分发
const handleFormat = (action: string) => {
  const inlineFormats: InlineFormatType[] = ['bold', 'italic', 'code', 'highlight', 'link']
  if (inlineFormats.includes(action as InlineFormatType)) {
    emit('inline-format', action as InlineFormatType)
    return
  }

  const paragraphFormats: ParagraphFormatType[] = ['heading1', 'heading2', 'heading3', 'quote']
  if (paragraphFormats.includes(action as ParagraphFormatType)) {
    emit('paragraph-format', action as ParagraphFormatType)
    return
  }

  // 其他都是块级插入
  emit('insert-block', action as BlockInsertType)
}
```

**优点**：

- ✅ 类型安全：TypeScript 精确类型检查
- ✅ 职责清晰：工具栏知道按钮类型，父组件直接映射方法
- ✅ 易扩展：新增按钮只需添加到对应分类

### 3.5 按钮配置

```typescript
// 行内格式按钮
const inlineButtons = [
  { action: 'bold', icon: 'Bold', title: '加粗 (Ctrl+B)' },
  { action: 'italic', icon: 'Italic', title: '斜体 (Ctrl+I)' },
  { action: 'code', icon: 'Code', title: '行内代码' },
  { action: 'highlight', icon: 'Highlighter', title: '高亮' },
  { action: 'link', icon: 'Link', title: '链接 (Ctrl+K)' },
]

// 段落格式按钮
const paragraphButtons = [
  { action: 'heading1', icon: 'Heading1', title: '一级标题' },
  { action: 'heading2', icon: 'Heading2', title: '二级标题' },
  { action: 'heading3', icon: 'Heading3', title: '三级标题' },
  { action: 'quote', icon: 'Quote', title: '引用' },
]

// 块级插入按钮
const blockButtons = [
  { action: 'codeBlock', icon: 'CodeSquare', title: '代码块' },
  { action: 'image', icon: 'Image', title: '图片' },
  { action: 'table', icon: 'Table', title: '表格' },
  { action: 'divider', icon: 'Minus', title: '分割线' },
]
```

---

## 四、MarkdownEditor.vue 详细设计

### 4.1 组件定位

**容器组件**，负责组合子组件并协调它们之间的通信。

### 4.2 职责清单

| 职责类别     | 具体内容                                      |
| ------------ | --------------------------------------------- |
| **组件组合** | 组合 EditorToolbar + EditorContent + 标题输入 |
| **事件转发** | 接收工具栏事件，转发给编辑器                  |
| **数据协调** | 管理 content 和 title 的双向绑定              |
| **API 暴露** | 暴露统一的对外 API                            |
| **样式容器** | 提供整体布局和样式                            |

### 4.3 数据流设计

#### Props（输入）

```typescript
interface Props {
  modelValue?: string // 编辑器内容（v-model）
  titleValue?: string // 标题内容（v-model:titleValue）
  showTitle?: boolean // 是否显示标题输入框
}
```

#### Emits（输出）

```typescript
interface Emits {
  (e: 'update:modelValue', value: string): void
  (e: 'update:titleValue', value: string): void
  (e: 'change', content: string, title: string): void // 统一变化事件
}
```

### 4.4 事件传递链

```
用户点击工具栏按钮
    ↓
EditorToolbar emit('inline-format', 'bold')
    ↓
MarkdownEditor handleInlineFormat('bold')
    ↓
editorContentRef.value.applyInlineFormat('bold')
    ↓
EditorContent 执行格式化
    ↓
EditorContent emit('update:modelValue', newContent)
    ↓
MarkdownEditor 接收并同步到 content.value
    ↓
MarkdownEditor emit('update:modelValue', content.value)
    ↓
父组件（使用者）接收更新
```

### 4.5 为什么需要中间变量 `content`？

**问题**：为什么不直接让 EditorContent 和父组件通信？

```vue
<!-- ❌ 如果这样写 -->
<EditorContent v-model="parentContent" />
```

**不行的原因**：

1. ❌ MarkdownEditor 无法拦截和处理内容变化
2. ❌ 无法实现 `change` 事件（同时传递 content 和 title）
3. ❌ 无法在未来添加中间层逻辑（如验证、转换等）

**解决方案**：使用本地副本

```typescript
// 创建可修改的本地副本
const content = ref(props.modelValue || '')
const title = ref(props.titleValue || '')

// 监听 Props 变化（父组件 → 本地）
watch([() => props.modelValue, () => props.titleValue], ([newContent, newTitle]) => {
  if (newContent !== undefined && newContent !== content.value) {
    content.value = newContent
  }
  if (newTitle !== undefined && newTitle !== title.value) {
    title.value = newTitle
  }
})

// 监听本地变化（本地 → 父组件）
watch(content, (newValue) => {
  emit('update:modelValue', newValue)
  emit('change', newValue, title.value)
})
```

### 4.6 暴露的 API

```typescript
defineExpose({
  // 便捷方法
  getContent: () => content.value,
  setContent: (value: string) => {
    content.value = value
  },
  getTitle: () => title.value,
  setTitle: (value: string) => {
    title.value = value
  },

  // 直接访问子组件
  editorContent: editorContentRef, // 可以调用所有底层 API
})
```

---

## 五、三个组件的协作关系

### 5.1 数据流向图

```
父组件（使用者）
    ↓ v-model (Props Down)
MarkdownEditor
    ├─ 本地副本：content, title
    ├─ 子组件1：EditorToolbar (无状态)
    │   └─ emit: inline-format, paragraph-format, insert-block
    │        ↓ (事件转发)
    └─ 子组件2：EditorContent (有状态)
        ├─ 拥有：editorRef, editorState, composables
        ├─ 接收：handleInlineFormat, handleParagraphFormat, handleInsertBlock
        └─ emit: update:modelValue
             ↓
        MarkdownEditor 同步到 content
             ↓ (Events Up)
        父组件接收 update:modelValue
```

### 5.2 通信方式对照表

| 通信路径                           | 方式                                     | 用途       |
| ------------------------------ | -------------------------------------- | -------- |
| 父 → MarkdownEditor             | Props (`modelValue`, `titleValue`)     | 初始化和外部更新 |
| MarkdownEditor → 父             | Events (`update:modelValue`, `change`) | 内容变化通知   |
| MarkdownEditor → EditorToolbar | 无（工具栏无状态）                              | -        |
| EditorToolbar → MarkdownEditor | Events (分类事件)                          | 用户点击按钮   |
| MarkdownEditor → EditorContent | Ref 调用方法                               | 执行格式化操作  |
| EditorContent → MarkdownEditor | Events (`update:modelValue`)           | 内容变化通知   |

### 5.3 关键设计原则

#### 1. 单向数据流（Props Down, Events Up）

```
Props 向下传递：父 → MarkdownEditor → EditorContent
Events 向上传递：EditorContent → MarkdownEditor → 父
```

#### 2. 数据就近原则

```
editorRef, editorState 在 EditorContent
    ↓
composables 也在 EditorContent 初始化
```

#### 3. 职责分离

```
EditorToolbar：纯 UI，无状态
EditorContent：核心逻辑，有状态
MarkdownEditor：协调器，桥梁
```

#### 4. 封装原则

```
父组件不需要知道：
  - EditorContent 内部有哪些 composables
  - 格式化是如何实现的
  - 历史记录是如何管理的

父组件只需要知道：
  - v-model 传入内容
  - 监听 update:modelValue 获取变化
  - 可以调用 editorContent 的方法
```

---

## 六、未来扩展方向

### 6.1 浮动工具栏

当前是固定工具栏（EditorToolbar），未来可以添加：

```
MarkdownEditor
    ├─ EditorToolbar (固定工具栏)
    ├─ FloatingToolbar (浮动工具栏) ⚡️ 新增
    └─ EditorContent
```

**实现方式**：

- 监听 EditorContent 的选区变化
- 计算选中文本的位置
- 显示浮动工具栏在选中文本上方

### 6.2 快捷键系统

在 EditorContent 中添加 `useShortcuts` composable：

```typescript
const shortcutsAPI = useShortcuts({
  'Ctrl+B': () => markdownAPI.applyInlineFormat('bold'),
  'Ctrl+I': () => markdownAPI.applyInlineFormat('italic'),
  'Ctrl+K': () => markdownAPI.applyInlineFormat('link'),
})
```

### 6.3 插件系统

```typescript
// MarkdownEditor.vue
const plugins = [ImageUploadPlugin, CodeHighlightPlugin, TableEditorPlugin]

plugins.forEach((plugin) => plugin.install(editorContentRef.value))
```

---

## 七、总结

### 核心设计思想

1. **容器/展示模式** - 分离 UI 和逻辑
2. **单向数据流** - 清晰的数据流向
3. **数据就近原则** - 在数据所在处初始化逻辑
4. **职责单一** - 每个组件只做一件事
5. **封装良好** - 父组件不关心子组件内部实现

### 组件定位总结

| 组件             | 定位     | 关键特征                             |
| ---------------- | -------- | ------------------------------------ |
| `EditorContent`  | 核心引擎 | 拥有状态、拥有 composables、暴露 API |
| `EditorToolbar`  | UI 展示  | 无状态、只发事件、纯展示             |
| `MarkdownEditor` | 协调器   | 组合子组件、转发事件、暴露统一 API   |

这种设计确保了组件的**低耦合、高内聚**，便于测试、维护和扩展。
