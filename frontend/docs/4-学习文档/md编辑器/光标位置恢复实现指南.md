# 光标位置恢复实现指南

## 一、任务目标

让撤销/重做后，光标能恢复到操作时的位置，而不是总是跳到编辑器末尾。

---

## 二、当前问题

### 测试场景

```
编辑器内容：第一行 第二行 第三行
                     ↑
                  光标在这里

用户操作：在第二行加粗
撤销后：光标应该回到第二行，但现在会跳到末尾
```

---

## 三、实现步骤

### 步骤1: 修改 EditTransaction 类型 ✅

**位置**：`types/editor.ts`

**现有代码**：

```typescript
export interface EditTransaction {
  id: string
  label: string
  content: string
  timestamp: number
}
```

**修改后**：

```typescript
export interface EditTransaction {
  id: string
  label: string
  content: string
  timestamp: number
  cursorPosition?: number // ⚡️ 新增：保存光标位置（可选）
}
```

---

### 步骤2: 修改 useHistory 的 pushTransaction ✅

**位置**：`useHistory.ts`

**现有代码**：

```typescript
const pushTransaction = (content: string, label: string = '未命名操作'): void => {
  const newTransaction: EditTransaction = {
    id: generateId(),
    label,
    content,
    timestamp: Date.now(),
  }
  // ...
}
```

**修改后**：

```typescript
const pushTransaction = (
  content: string,
  label: string = '未命名操作',
  cursorPosition?: number, // ⚡️ 新增参数
): void => {
  const newTransaction: EditTransaction = {
    id: generateId(),
    label,
    content,
    timestamp: Date.now(),
    cursorPosition, // ⚡️ 保存光标位置
  }

  // ... 其他逻辑不变
}
```

---

### 步骤3: 修改 undo/redo 返回类型 ✅

**位置**：`useHistory.ts`

**现有代码**：

```typescript
const undo = (): string | null => {
  // ...
  return targetTransaction.content
}

const redo = (): string | null => {
  // ...
  return targetTransaction.content
}
```

**修改后**：

```typescript
const undo = (): { content: string; cursorPosition?: number } | null => {
  if (historyState.currentIndex < 0) {
    console.warn('[useHistory] 无法撤销：已经在初始状态')
    return null
  }

  historyState.currentIndex--

  if (historyState.currentIndex === -1) {
    console.log('[useHistory] 撤销到初始状态')
    return { content: '', cursorPosition: 0 } // ⚡️ 返回对象
  } else {
    const targetTransaction = historyState.transactions[historyState.currentIndex]
    console.log(`[useHistory] 撤销到: ${targetTransaction!.label}`)
    return {
      content: targetTransaction!.content,
      cursorPosition: targetTransaction!.cursorPosition, // ⚡️ 返回光标位置
    }
  }
}

const redo = (): { content: string; cursorPosition?: number } | null => {
  if (historyState.currentIndex >= historyState.transactions.length - 1) {
    console.warn('[useHistory] 无法重做：已经在最新状态')
    return null
  }

  historyState.currentIndex++

  const targetTransaction = historyState.transactions[historyState.currentIndex]
  console.log(`[useHistory] 重做到: ${targetTransaction!.label}`)
  return {
    content: targetTransaction!.content,
    cursorPosition: targetTransaction!.cursorPosition, // ⚡️ 返回光标位置
  }
}
```

---

### 步骤4: 在 useSelection 中添加光标恢复方法 ✅

**位置**：`useSelection.ts`

**新增方法**：

```typescript
/**
 * 恢复光标到编辑器末尾（fallback方法）
 */
const restoreCursorToEnd = (): void => {
  if (!editorRef.value) return

  editorRef.value.focus()
  const range = document.createRange()
  const selection = window.getSelection()
  range.selectNodeContents(editorRef.value)
  range.collapse(false) // false = 末尾
  selection?.removeAllRanges()
  selection?.addRange(range)
}

// 在 return 中暴露
return {
  // ... 其他方法
  restoreCursorToEnd, // ⚡️ 新增
}
```

---

### 步骤5: 修改 useMarkdown 调用 pushTransaction 时传入光标 ✅

**位置**：`useMarkdown.ts`

**现有代码**（以 applyInlineFormat 为例）：

```typescript
historyModule.pushTransaction(state.content, `应用${action}格式`)
```

**修改后**：

```typescript
const { start } = getSelectionInfo() // 获取当前光标位置
historyModule.pushTransaction(state.content, `应用${action}格式`, start)
```

**需要修改的地方**：

1. `applyInlineFormat` - 3处
2. `applyParagraphFormat` - 1处
3. `insertBlock` - 1处

---

### 步骤6: 修改 EditorContent 调用 pushTransaction 时传入光标 ✅

**位置**：`EditorContent.vue`

**handleInput 中**：

```typescript
inputTimer = window.setTimeout(() => {
  const cursorPos = selectionAPI.getSelectionInfo().start // ⚡️ 获取光标
  historyAPI.pushTransaction(newContent, '输入文本', cursorPos)
}, 500)
```

**handleKeyDown 撤销中**：

```typescript
if (inputTimer) {
  clearTimeout(inputTimer)
  inputTimer = null
  const cursorPos = selectionAPI.getSelectionInfo().start // ⚡️ 获取光标
  historyAPI.pushTransaction(editorState.content, '输入文本', cursorPos)
}
```

**handleKeyDown 重做中**（同样）：

```typescript
if (inputTimer) {
  clearTimeout(inputTimer)
  inputTimer = null
  const cursorPos = selectionAPI.getSelectionInfo().start // ⚡️ 获取光标
  historyAPI.pushTransaction(editorState.content, '输入文本', cursorPos)
}
```

---

### 步骤7: 修改 EditorContent 恢复光标 🔥

**位置**：`EditorContent.vue` 的 `handleKeyDown`

**现有代码（撤销）**：

```typescript
const previousContent = historyAPI.undo()
if (previousContent !== null && editorRef.value) {
  editorRef.value.innerHTML = previousContent
  editorState.content = previousContent
  emit('update:modelValue', previousContent)
}
```

**修改后**：

```typescript
const result = historyAPI.undo()
if (result !== null && editorRef.value) {
  // 1. 恢复内容
  editorRef.value.innerHTML = result.content
  editorState.content = result.content
  emit('update:modelValue', result.content)

  // 2. 恢复光标
  if (result.cursorPosition !== undefined) {
    selectionAPI.setCursor(result.cursorPosition)
  } else {
    selectionAPI.restoreCursorToEnd() // fallback
  }
}
```

**重做部分（同样修改）**：

```typescript
const result = historyAPI.redo()
if (result !== null && editorRef.value) {
  editorRef.value.innerHTML = result.content
  editorState.content = result.content
  emit('update:modelValue', result.content)

  if (result.cursorPosition !== undefined) {
    selectionAPI.setCursor(result.cursorPosition)
  } else {
    selectionAPI.restoreCursorToEnd()
  }
}
```

---

## 四、完整修改清单

### types/editor.ts

- [x] 在 `EditTransaction` 中添加 `cursorPosition?: number`

### useHistory.ts

- [x] `pushTransaction` 添加 `cursorPosition` 参数
- [x] `undo` 返回类型改为 `{ content: string; cursorPosition?: number } | null`
- [x] `redo` 返回类型改为 `{ content: string; cursorPosition?: number } | null`
- [x] `undo` 逻辑中返回光标位置
- [x] `redo` 逻辑中返回光标位置

### useSelection.ts

- [x] 添加 `restoreCursorToEnd()` 方法

### useMarkdown.ts

- [x] `applyInlineFormat` 调用时传入光标（3处）
- [x] `applyParagraphFormat` 调用时传入光标
- [x] `insertBlock` 调用时传入光标

### EditorContent.vue

- [x] `handleInput` 防抖记录时传入光标
- [x] 撤销时强制记录传入光标
- [x] 重做时强制记录传入光标
- [x] 撤销后恢复光标
- [x] 重做后恢复光标

---

## 五、测试方法

### 测试1: 中间位置操作

```
1. 输入："第一行 第二行 第三行"
2. 光标定位到"第二行"
3. 加粗 → "第一行 **第二行** 第三行"
4. 按 Ctrl+Z
5. 预期：光标回到"第二行"的位置 ✅
```

### 测试2: 输入后撤销

```
1. 输入："hello world"
2. 光标在"world"后
3. 等待 >500ms（防抖记录）
4. 按 Ctrl+Z
5. 预期：光标在删除位置（"hello "后）✅
```

### 测试3: 多次撤销/重做

```
1. 输入："test"，在不同位置操作
2. 连续按 Ctrl+Z 多次
3. 预期：每次撤销后，光标都在该操作的位置 ✅
```

---

## 六、注意事项

1. **光标位置的含义**：
   - `cursorPosition` 是相对于编辑器根元素的绝对字符索引
   - 由 `getSelectionInfo().start` 获取

2. **为什么是可选的**：
   - 旧的历史记录可能没有光标信息
   - 某些操作可能不需要恢复光标

3. **fallback 策略**：
   - 如果没有保存光标位置，使用 `restoreCursorToEnd()`
   - 至少保证不会报错

---

开始实现吧！按照步骤1-7逐步完成。💪
