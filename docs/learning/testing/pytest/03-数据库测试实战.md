# 数据库测试实战

## 🎯 数据库测试的核心挑战

数据库测试需要解决以下关键问题：

1. **隔离性**：确保测试间不相互影响
2. **性能**：避免重复创建昂贵的数据库连接
3. **清理**：确保测试数据不会残留
4. **真实性**：尽可能接近生产环境的数据库行为
5. **约束测试**：验证数据库约束和完整性

## 🏗️ 数据库测试架构设计

### 分层测试策略

```python
# 测试数据库层级结构
"""
Session Scope (全局)
├── 数据库 URL 配置
└── 全局测试配置

Module Scope (文件级)
├── 数据库引擎
├── 表结构创建
└── 会话工厂

Class Scope (类级)
└── 特定测试类的共享资源

Function Scope (函数级)
├── 数据库会话（隔离）
├── 测试数据
└── 事务管理
"""
```

### 完整的测试架构

```python
# tests/conftest.py
import pytest
import uuid
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.db.database import Base
from app.models import User, Post, Comment

# ========== Session Level ==========
@pytest.fixture(scope="session")
def database_url():
    """测试数据库配置"""
    return "sqlite:///:memory:"

@pytest.fixture(scope="session")
def test_config():
    """全局测试配置"""
    return {
        "TESTING": True,
        "DATABASE_ECHO": False,  # 是否显示 SQL 语句
        "ISOLATION_LEVEL": "AUTOCOMMIT"
    }

# ========== Module Level ==========
@pytest.fixture(scope="module")
def engine(database_url, test_config):
    """数据库引擎 - 每个测试模块创建一次"""
    print(f"🚀 创建数据库引擎: {database_url}")

    engine = create_engine(
        database_url,
        echo=test_config["DATABASE_ECHO"],
        connect_args={"check_same_thread": False}  # SQLite 特定配置
    )

    # 创建所有表
    Base.metadata.create_all(engine)

    yield engine

    # 模块结束时清理
    print("🗑️ 清理数据库引擎")
    engine.dispose()

@pytest.fixture(scope="module")
def session_factory(engine):
    """会话工厂 - 每个测试模块创建一次"""
    return sessionmaker(bind=engine)

# ========== Function Level ==========
@pytest.fixture
def db_session(session_factory):
    """数据库会话 - 每个测试函数独立"""
    print("🔗 创建数据库会话")
    session = session_factory()

    try:
        yield session
    finally:
        print("🧹 清理数据库会话")
        session.rollback()  # 回滚所有未提交的事务
        session.close()     # 关闭会话

@pytest.fixture
def sample_user_data():
    """用户测试数据 - 每次生成唯一数据"""
    unique_id = str(uuid.uuid4())[:8]
    return {
        "username": f"testuser_{unique_id}",
        "email": f"test_{unique_id}@example.com",
        "password_hash": "hashed_password_123",
        "nickname": f"测试用户_{unique_id}"
    }
```

## 🧪 模型测试最佳实践

### 1. 基础 CRUD 测试

```python
# tests/test_models/test_user.py
import pytest
import uuid
from sqlalchemy.exc import IntegrityError
from app.models.user import User, UserRole

class TestUserModel:
    """User 模型完整测试套件"""

    def test_user_creation(self, db_session, sample_user_data):
        """测试基本用户创建"""
        # 创建用户
        user = User(**sample_user_data)
        db_session.add(user)
        db_session.commit()

        # 验证基本属性
        assert user.id is not None
        assert isinstance(user.id, uuid.UUID)
        assert user.username == sample_user_data["username"]
        assert user.email == sample_user_data["email"]

        # 验证默认值
        assert user.role == UserRole.USER
        assert user.is_active is True
        assert user.is_verified is False
        assert user.created_at is not None
        assert user.updated_at is not None

    def test_user_query(self, db_session, sample_user_data):
        """测试用户查询"""
        # 创建用户
        original_user = User(**sample_user_data)
        db_session.add(original_user)
        db_session.commit()

        # 按 ID 查询
        found_user = db_session.query(User).filter_by(id=original_user.id).first()
        assert found_user is not None
        assert found_user.username == sample_user_data["username"]

        # 按用户名查询
        found_user = db_session.query(User).filter_by(
            username=sample_user_data["username"]
        ).first()
        assert found_user is not None
        assert found_user.id == original_user.id

    def test_user_update(self, db_session, sample_user_data):
        """测试用户更新"""
        # 创建用户
        user = User(**sample_user_data)
        db_session.add(user)
        db_session.commit()

        original_updated_at = user.updated_at

        # 更新用户
        user.nickname = "新昵称"
        db_session.commit()

        # 验证更新
        assert user.nickname == "新昵称"
        assert user.updated_at > original_updated_at  # 更新时间应该变化

    def test_user_deletion(self, db_session, sample_user_data):
        """测试用户删除"""
        # 创建用户
        user = User(**sample_user_data)
        db_session.add(user)
        db_session.commit()
        user_id = user.id

        # 删除用户
        db_session.delete(user)
        db_session.commit()

        # 验证删除
        deleted_user = db_session.query(User).filter_by(id=user_id).first()
        assert deleted_user is None
```

### 2. 约束测试

```python
class TestUserConstraints:
    """测试数据库约束"""

    def test_username_unique_constraint(self, db_session, sample_user_data):
        """测试用户名唯一约束"""
        # 创建第一个用户
        user1 = User(**sample_user_data)
        db_session.add(user1)
        db_session.commit()

        # 尝试创建相同用户名的用户
        duplicate_data = sample_user_data.copy()
        duplicate_data["email"] = "different@example.com"  # 邮箱不同
        user2 = User(**duplicate_data)
        db_session.add(user2)

        # 应该抛出完整性错误
        with pytest.raises(IntegrityError):
            db_session.commit()

    def test_email_unique_constraint(self, db_session, sample_user_data):
        """测试邮箱唯一约束"""
        # 创建第一个用户
        user1 = User(**sample_user_data)
        db_session.add(user1)
        db_session.commit()

        # 尝试创建相同邮箱的用户
        duplicate_data = sample_user_data.copy()
        duplicate_data["username"] = "different_user"  # 用户名不同
        user2 = User(**duplicate_data)
        db_session.add(user2)

        # 应该抛出完整性错误
        with pytest.raises(IntegrityError):
            db_session.commit()

    def test_required_fields(self, db_session):
        """测试必填字段约束"""
        # 缺少用户名
        with pytest.raises((IntegrityError, ValueError)):
            user = User(email="test@example.com", password_hash="hash")
            db_session.add(user)
            db_session.commit()

        # 回滚以清理状态
        db_session.rollback()

        # 缺少邮箱
        with pytest.raises((IntegrityError, ValueError)):
            user = User(username="testuser", password_hash="hash")
            db_session.add(user)
            db_session.commit()
```

### 3. 关系测试

```python
class TestUserRelationships:
    """测试模型关系"""

    @pytest.fixture
    def user_with_posts(self, db_session):
        """创建带有文章的用户"""
        # 创建用户
        user = User(
            username="author_user",
            email="author@example.com",
            password_hash="hash",
            nickname="作者"
        )
        db_session.add(user)
        db_session.commit()

        # 创建文章
        posts = []
        for i in range(3):
            post = Post(
                title=f"文章标题 {i+1}",
                content=f"文章内容 {i+1}",
                slug=f"post-{i+1}",
                author_id=user.id
            )
            posts.append(post)

        db_session.add_all(posts)
        db_session.commit()

        return user, posts

    def test_user_posts_relationship(self, db_session, user_with_posts):
        """测试用户与文章的一对多关系"""
        user, expected_posts = user_with_posts

        # 通过关系加载文章
        assert len(user.posts) == 3

        # 验证每篇文章的作者
        for post in user.posts:
            assert post.author_id == user.id
            assert post.author.username == user.username

    def test_cascade_delete(self, db_session, user_with_posts):
        """测试级联删除"""
        user, posts = user_with_posts
        post_ids = [post.id for post in posts]

        # 删除用户
        db_session.delete(user)
        db_session.commit()

        # 验证相关文章也被删除（如果配置了级联删除）
        remaining_posts = db_session.query(Post).filter(
            Post.id.in_(post_ids)
        ).all()

        # 根据你的级联配置，这里可能是 0 或保持原数量
        # 如果配置了 CASCADE，应该是 0
        assert len(remaining_posts) == 0
```

## 🏭 测试数据工厂

### 工厂模式实现

```python
# tests/factories.py
import uuid
from datetime import datetime
from app.models import User, Post, Comment, UserRole, PostStatus

class UserFactory:
    """用户工厂"""

    @staticmethod
    def create(db_session, **kwargs):
        """创建用户"""
        unique_id = str(uuid.uuid4())[:8]

        defaults = {
            "username": f"user_{unique_id}",
            "email": f"user_{unique_id}@example.com",
            "password_hash": "hashed_password",
            "nickname": f"用户_{unique_id}",
            "role": UserRole.USER,
            "is_active": True,
            "is_verified": False
        }

        defaults.update(kwargs)
        user = User(**defaults)
        db_session.add(user)
        db_session.commit()
        return user

    @staticmethod
    def create_admin(db_session, **kwargs):
        """创建管理员用户"""
        kwargs["role"] = UserRole.ADMIN
        return UserFactory.create(db_session, **kwargs)

class PostFactory:
    """文章工厂"""

    @staticmethod
    def create(db_session, author=None, **kwargs):
        """创建文章"""
        if author is None:
            author = UserFactory.create(db_session)

        unique_id = str(uuid.uuid4())[:8]

        defaults = {
            "title": f"测试文章_{unique_id}",
            "content": f"这是测试文章内容_{unique_id}",
            "slug": f"test-post-{unique_id}",
            "status": PostStatus.PUBLISHED,
            "author_id": author.id
        }

        defaults.update(kwargs)
        post = Post(**defaults)
        db_session.add(post)
        db_session.commit()
        return post

# 在 conftest.py 中注册工厂 fixtures
@pytest.fixture
def user_factory(db_session):
    """用户工厂 fixture"""
    def _create_user(**kwargs):
        return UserFactory.create(db_session, **kwargs)
    return _create_user

@pytest.fixture
def post_factory(db_session):
    """文章工厂 fixture"""
    def _create_post(author=None, **kwargs):
        return PostFactory.create(db_session, author=author, **kwargs)
    return _create_post
```

### 使用工厂的测试

```python
class TestWithFactories:
    """使用工厂的测试示例"""

    def test_multiple_users(self, user_factory):
        """测试多用户场景"""
        # 轻松创建多个用户
        users = [user_factory() for _ in range(5)]

        assert len(users) == 5
        assert len(set(user.username for user in users)) == 5  # 用户名唯一

    def test_user_with_posts(self, user_factory, post_factory):
        """测试用户与文章关系"""
        # 创建作者
        author = user_factory(username="prolific_author")

        # 为作者创建多篇文章
        posts = [post_factory(author=author) for _ in range(3)]

        assert len(posts) == 3
        for post in posts:
            assert post.author_id == author.id

    def test_admin_permissions(self, user_factory):
        """测试管理员权限"""
        # 创建普通用户和管理员
        regular_user = user_factory()
        admin_user = user_factory(role=UserRole.ADMIN)

        assert regular_user.is_admin is False
        assert admin_user.is_admin is True
```

## 🔄 事务和回滚测试

### 事务隔离测试

```python
class TestTransactionIsolation:
    """测试事务隔离"""

    def test_rollback_on_error(self, db_session, user_factory):
        """测试错误时的回滚"""
        # 创建一个用户
        user1 = user_factory()

        try:
            # 开始事务
            user2 = User(
                username=user1.username,  # 故意重复用户名
                email="different@example.com",
                password_hash="hash"
            )
            db_session.add(user2)
            db_session.commit()  # 这里会失败
        except IntegrityError:
            db_session.rollback()

        # 验证第一个用户仍然存在
        assert db_session.query(User).filter_by(
            username=user1.username
        ).count() == 1

    def test_savepoint_rollback(self, db_session, user_factory):
        """测试保存点回滚"""
        user1 = user_factory()

        # 创建保存点
        savepoint = db_session.begin_nested()

        try:
            # 在保存点中做一些操作
            user2 = user_factory()

            # 故意触发错误
            user3 = User(
                username=user1.username,  # 重复用户名
                email="error@example.com",
                password_hash="hash"
            )
            db_session.add(user3)
            db_session.commit()
        except IntegrityError:
            # 回滚到保存点
            savepoint.rollback()

        # user1 应该仍存在，user2 应该被回滚
        assert db_session.query(User).count() == 1
```

## 📊 性能测试

### 查询性能测试

```python
import time
import pytest

class TestPerformance:
    """数据库性能测试"""

    def test_bulk_insert_performance(self, db_session):
        """测试批量插入性能"""
        start_time = time.time()

        # 批量创建用户
        users = []
        for i in range(1000):
            user = User(
                username=f"bulk_user_{i}",
                email=f"bulk_{i}@example.com",
                password_hash="hash",
                nickname=f"批量用户_{i}"
            )
            users.append(user)

        # 批量添加
        db_session.add_all(users)
        db_session.commit()

        elapsed = time.time() - start_time

        # 验证插入完成
        assert db_session.query(User).count() >= 1000

        # 性能断言（可根据需要调整）
        assert elapsed < 5.0, f"批量插入耗时过长: {elapsed:.2f}秒"

    @pytest.mark.slow
    def test_complex_query_performance(self, db_session, user_factory, post_factory):
        """测试复杂查询性能"""
        # 创建测试数据
        authors = [user_factory() for _ in range(10)]

        for author in authors:
            for i in range(10):
                post_factory(author=author, title=f"文章_{i}")

        start_time = time.time()

        # 复杂查询：获取所有用户及其文章数量
        result = db_session.query(User).join(Post).group_by(User.id).all()

        elapsed = time.time() - start_time

        assert len(result) == 10
        assert elapsed < 1.0, f"复杂查询耗时过长: {elapsed:.2f}秒"
```

## 📝 测试覆盖率

### 配置覆盖率检查

```ini
# pytest.ini
[tool:pytest]
addopts =
    --cov=app/models
    --cov=app/db
    --cov-report=term-missing
    --cov-report=html:htmlcov
    --cov-fail-under=80
```

### 关键覆盖区域

```python
class TestCoverage:
    """确保测试覆盖关键代码路径"""

    def test_model_methods_coverage(self, db_session, user_factory):
        """测试模型方法覆盖率"""
        user = user_factory()

        # 测试所有用户方法
        assert user.is_admin is False
        assert user.is_regular_user is True

        user.promote_to_admin()
        assert user.is_admin is True

        user.deactivate()
        assert user.is_active is False

        user.activate()
        assert user.is_active is True

        user.verify_email()
        assert user.is_verified is True

    def test_edge_cases(self, db_session):
        """测试边界情况"""
        # 测试最大长度字段
        long_username = "a" * 50  # 假设最大长度是 50
        user = User(
            username=long_username,
            email="long@example.com",
            password_hash="hash"
        )
        db_session.add(user)
        db_session.commit()

        assert user.username == long_username

    def test_string_representations(self, user_factory):
        """测试字符串表示方法"""
        user = user_factory(username="testuser", nickname="测试用户")

        # 测试 __str__
        str_repr = str(user)
        assert "测试用户" in str_repr
        assert "@testuser" in str_repr

        # 测试 __repr__
        repr_str = repr(user)
        assert "User(" in repr_str
        assert "username='testuser'" in repr_str
```

## 💡 最佳实践总结

### 数据库测试架构

1. **分层设计**：Session > Module > Class > Function
2. **合理的作用域**：重资源用高作用域，隔离需求用低作用域
3. **自动清理**：使用 yield fixtures 确保资源释放

### 测试数据管理

1. **唯一性**：使用 UUID 避免数据冲突
2. **工厂模式**：便于创建复杂测试数据
3. **最小数据集**：只创建测试需要的最少数据

### 测试组织

1. **按功能分组**：创建、查询、更新、删除
2. **约束测试**：独立测试所有数据库约束
3. **关系测试**：验证模型间的关联关系

### 性能考虑

1. **批量操作**：测试大量数据的性能
2. **查询优化**：验证索引和查询效率
3. **内存数据库**：使用 SQLite 内存数据库提升测试速度

下一步学习：[FastAPI 集成测试](./04-FastAPI集成测试.md)